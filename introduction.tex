\chapter{Introduction}

\section{Problem Justification}



%TODO part of COMPSs explanation. 



\section{Objectives}



Once finished, I will analyze the resulting code at many levels. These aspects are going to be the secondary objectives:

\begin{itemize}
\item \textbf{Analysis of the performance}, I will compare the original version with the refactor to see which one is faster.
\item \textbf{Evaluation of the programming model} to see which version offers more features. This includes usability, code size or documentation amongst others.
\item \textbf{Test FIND GOOD NAME}. 
\end{itemize}


Almost all the software used is under development. To limit the problems I will work on a single modification at a time. Each iteration will use the same pattern composed of three milestones (acting as tertiary objectives):  
\begin{enumerate}
\item \textbf{Program Analysis} of the current performance. This will be useful for two reasons. On the one hand I need to analyse the program in order to be able to compare it with the modified one. On the other, a deep analysis will help to identify the algorithm's bottlenecks, slowest parts and best modifications to perform.
\item \textbf{Optimization} of the algorithm. Because each clustering execution is unrelated to others this step is embarrassingly parallel and so, even prior to the analysis part, some sort of parallelization will surely speed up the algorithm. 
\item \textbf{Optimization's analysis}. Finally we will analyse, compare and evaluate the modifications. Here the focus will be to analyse the changes introduced by the last modification and how it affects the performance and usage. If the changes introduced are valuable I will merge them and start another iteration. Otherwise, if the proposed modification is not successful, I will decide here if I should discard the proposal or try to find another way to implement it.
\end{enumerate}

More detailed description of this development plan on \ref{sec:methodology} Methodology section.

